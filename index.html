<meta charset="UTF-8">
<html>
<script type="text/javascript">
  var canvas, ctx, flagOver, flagDown = false,
  prevX = 0,
  currX = 0,
  prevY = 0,
  currY = 0,
  dot_flag = false;

  var recordedPattern = new Array();
  var curentLine;

  // test data, remove for production
  var test_k2 = [ [ [0,10], [30,10], [60,10] ]   , [ [170,10], [200,10], [220,10] ] ];
  var test_k21 = [ [ [10,15], [30,15], [50,15]  ], [ [50,15], [55,15], [60,15] ], [ [170,15], [175,15], [180,15]  ], [ [180,15], [220,15]  ] ];
  var test_k22 = [ [ [0,15], [40,15] ], [ [40,15], [50,15] ], [ [50,15], [50,15]], [ [170,15], [220,15]  ] ];
 var test_k23 = [ [ [0,15], [60,15] ], [ [170,15], [180,15] ], [ [180,15], [190,15]], [ [170,15], [220,15]  ] ];

  var refPatterns = [ ["い", 2, [  [[0,15], [30,13], [60,14]], [[0,10], [30,10], [60,10]] ] ] ,
                      ["を", 3, [  [[0,17], [30,17], [60,17]], [[0,15], [30,13], [60,12]], [[0,15], [30,13], [60,12]] ]  ] 
					] 
  
		
  function init() {
    canvas = document.getElementById('can');
    ctx = canvas.getContext("2d");
    w = canvas.width;
    h = canvas.height;

    canvas.addEventListener("mousemove", function (e) {
      findxy('move', e)
    }, false);
    canvas.addEventListener("mousedown", function (e) {
      findxy('down', e)
    }, false);
    canvas.addEventListener("mouseup", function (e) {
      findxy('up', e)
    }, false);
    canvas.addEventListener("mouseout", function (e) {
      findxy('out', e)
    }, false);
	canvas.addEventListener("mouseover", function (e) {
      findxy('over', e)
    }, false);
  }

  function draw() {
    ctx.beginPath();
    ctx.moveTo(prevX, prevY);
    ctx.lineTo(currX, currY);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.closePath();
  }

  function deleteLast() {
    ctx.clearRect(0, 0, w, h);
    for(var i = 0;i<recordedPattern.length-1;i++) {
      var stroke_i = recordedPattern[i];
      for(var j = 0; j<stroke_i.length-1;j++) {
        prevX = stroke_i[j][0];
        prevY = stroke_i[j][1];

        currX = stroke_i[j+1][0];
        currY = stroke_i[j+1][1];
        draw();
      }
    }
    recordedPattern.pop();
  }

  function erase() {
    ctx.clearRect(0, 0, w, h);
    recordedPattern.length = 0;
  }

  // add flag for button down!!!
  function findxy(res, e) {
    if (res == 'down') {
      prevX = currX;
      prevY = currY;
      currX = e.clientX - canvas.offsetLeft;
      currY = e.clientY - canvas.offsetTop;
      //console.log("DOWN");
      currentLine = new Array();
      currentLine.push([currX, currY]);

      flagDown = true;
	  flagOver = true;
      dot_flag = true;
      if (dot_flag) {
        ctx.beginPath();
        ctx.fillRect(currX, currY, 2, 2);
        ctx.closePath();
        dot_flag = false;
      }
    }
    if (res == 'up') {
      flagDown = false;
	  //console.log("UP");
	  if(flagOver == true) {
          recordedPattern.push(currentLine);
	  }
    }

    if (res == "out") {
      flagOver = false;
	  if(flagDown == true) {
	      recordedPattern.push(currentLine);
	  }
	  flagDown = false;
	  //console.log("OUT");
	  //if(currentLine.length != 0) {
	  //recordedPattern.push(currentLine);
	  //}
    }
	
	if (res == "over") {
      //flagOver = true;
	  //console.log("OVER");
	  //if(currentLine.length != 0) {
	  //recordedPattern.push(currentLine);
	  //}
    }

    if (res == 'move') {
	//console.log("MOVE");
      if (flagOver && flagDown) {
        prevX = currX;
        prevY = currY;
        currX = e.clientX - canvas.offsetLeft;
        currY = e.clientY - canvas.offsetTop;
        currentLine.push([prevX, prevY]);
        currentLine.push([currX, currY]);
        draw();
      }
    }
  }

  function redraw() {
      ctx.clearRect(0, 0, w, h);
      for(var i = 0;i<recordedPattern.length;i++) {
        var stroke_i = recordedPattern[i]
        for(var j = 0; j<stroke_i.length-1;j++) {
          prevX = stroke_i[j][0];
          prevY = stroke_i[j][1];

          currX = stroke_i[j+1][0];
          currY = stroke_i[j+1][1];
          draw();
        }
      }
  }

  function recognize() {
    document.getElementById("candidateList").innerHTML = "日本";
  }

  // linearly stretch drawn symbol
  function normalizeLinear() {

    var normalizedPattern = new Array();
    newHeight = 256;
    newWidth = 256;
    xMin = 256;
    xMax = 0;
    yMin = 256;
    yMax = 0;
    // first determine drawn character width / length
    for(var i = 0;i<recordedPattern.length;i++) {
      var stroke_i = recordedPattern[i];
      for(var j = 0; j<stroke_i.length;j++) {
        x = stroke_i[j][0];
        y = stroke_i[j][1];
        if(x < xMin) {
          xMin = x;
        }
        if(x > xMax) {
          xMax = x;
        }
        if(y < yMin) {
          yMin = y;
        }
        if(y > yMax) {
          yMax = y;
        }
      }
    }
    oldHeight = Math.abs(yMax - yMin);
    oldWidth  = Math.abs(xMax - xMin);
    if(oldHeight > oldWidth) {
      oldWidth = oldHeight;
    } else {
      oldHeight = oldWidth;
    }

    normalizedPattern = new Array();
    // normalize
    for(var i = 0;i<recordedPattern.length;i++) {
      var stroke_i = recordedPattern[i];
      var normalized_stroke_i = new Array();
      for(var j = 0; j<stroke_i.length;j++) {
        x = stroke_i[j][0];
        y = stroke_i[j][1];
        xNorm = (x - xMin) * (newWidth / oldWidth) ;
        yNorm = (y - yMin) * (newHeight / oldHeight);
        normalized_stroke_i.push([xNorm, yNorm]);
      }
      normalizedPattern.push(normalized_stroke_i);
    }
    recordedPattern = normalizedPattern;
    redraw();
  }
  
  function euclid(x1y1, x2y2) {
      var a = x1y1[0] - x2y2[0];
      var b = x1y1[1] - x2y2[1];
      var c = Math.sqrt( a*a + b*b );
	  return c;
  }

  // extract points in regular intervals
  function extractFeatures(kanji, interval) {
      var extractedPattern = new Array();
      var nrStrokes = kanji.length;
	  for(var i = 0;i<nrStrokes;i++) {
	      var stroke_i = kanji[i];
		  var extractedStroke_i = new Array();
		  var dist = 0.0;
	      var j = 0;
		  while(j < stroke_i.length) {
		      // always add first point
		      if(j==0) {
			  	  var x1y1 = stroke_i[0];
		          extractedStroke_i.push(x1y1);
			  }
		      if(j > 0) {
			      var x1y1 = stroke_i[j-1];
				  var x2y2 = stroke_i[j];
		          dist += euclid(x1y1, x2y2);
              }
			  if((dist >= interval) && (j>1)) {
			      dist = dist - interval;
				  var x1y1 = stroke_i[j];
				  extractedStroke_i.push(x1y1);
			  }
			  j++;
		  }
		  // if we so far have only one point, always add last point
		  if(extractedStroke_i.length == 1) {
		      var x1y1 = stroke_i[stroke_i.length-1];
		      extractedStroke_i.push(x1y1);
		  } else {
		      if(dist > (0.75 * interval)) {
			      var x1y1 = stroke_i[stroke_i.length-1];
		          extractedStroke_i.push(x1y1);
			  }		  
		  }
		  extractedPattern.push(extractedStroke_i);
	  }
      return extractedPattern;
   }
   
   function extractTest() {
      var ex = extractFeatures(recordedPattern, 20.);
	  recordedPattern = ex;

      redraw();
   }
   
   function endPointDistance(pattern1, pattern2) {
       var dist = 0;
	   var l1 = pattern1.length;
	   var l2 = pattern2.length;
       if(l1 == 0 || l2 == 0) {
          return 0;
       } else {
	       var x1y1 = pattern1[0];
		   var x2y2 = pattern2[0];
		   dist += (Math.abs(x1y1[0] - x2y2[0]) + Math.abs(x1y1[1] - x2y2[1]));
           x1y1 = pattern1[l1-1];
		   x2y2 = pattern2[l2-1];
		   dist += (Math.abs(x1y1[0] - x2y2[0]) + Math.abs(x1y1[1] - x2y2[1]));
	   }
	   return dist;
   }
   
   function initialDistance(pattern1, pattern2) {
       var l1 = pattern1.length;
	   var l2 = pattern2.length;
	   var lmin = Math.min(l1,l2);
	   var dist = 0;
	   for(var i = 0; i<lmin;i++) {
	       var x1y1 = pattern1[i];
		   var x2y2 = pattern2[i];
	       dist += (Math.abs(x1y1[0] - x2y2[0]) + Math.abs(x1y1[1] - x2y2[1]));
	   }
	   return dist;
   }
   
   function getLargerAndSize(pattern1, pattern2) {
	   var l1 = pattern1.length;
	   var l2 = pattern2.length;
	   // definitions as in paper 
	   // i.e. n is larger 
	   var n = l1;
	   var m = l2;
	   var k1 = pattern1;
	   var k2 = pattern2;
	   if(l1 < l2) {
	       m = l1;
		   n = l2;
		   k1 = pattern2;
		   k2 = pattern1;
	   }	   	   
       return [k1,k2,n,m];
   }
   
   function wholeWholeDistance(pattern1, pattern2) {
       var [k1,k2,n,m] = getLargerAndSize(pattern1, pattern2);
	   // larger is now k1 with length n
	   var dist = 0;
	   for(var i = 0; i<m;i++) {
	       j_of_i = parseInt(parseInt(n/m) * i) + 1;
		   var x1y1 = k1[j_of_i];
		   var x2y2 = k2[i];
	       dist += (Math.abs(x1y1[0] - x2y2[0]) + Math.abs(x1y1[1] - x2y2[1]));
	   }
	   return parseInt(dist/m);
   }
   
   function initStrokeMap(pattern1, pattern2, distanceMetric) {
	   var [k1,k2,n,m] = getLargerAndSize(pattern1, pattern2);
	   // larger is now k1 with length n
	   var map = new Array();
	   for(var i=0;i<n;i++) {
	      map[i] = -1;
	   }
	   var free = new Array();
	   for(var i=0;i<n;i++) {
	      free[i] = true;
	   }
	   for(var i=0;i<m;i++) {
           minDist = 10000000;
		   min_j = -1;
		   for(var j=0;j<n;j++) {
		       if(free[j] == true) {
			       var d = distanceMetric(k1[j],k2[i]);
  			       if(d < minDist) {
				       minDist = d;
					   min_j = j;
			       }
			   }
		   }
		   free[min_j] = false;
           map[min_j] = i;
       }	   
	   return map;   
    }

	function getMap(pattern1, pattern2, distanceMetric) {
       var [k1,k2,n,m] = getLargerAndSize(pattern1, pattern2);
	   // larger is now k1 with length n
	   var L = 3;
	   var map = initStrokeMap(k1, k2, distanceMetric);
	   for(var l=0;l<L;l++) {
	       for(var i=0;i<map.length;i++) {
		       if(map[i] != -1) {
                   dii = distanceMetric(k1[i], k2[map[i]]);
				   for(var j=0;j<map.length;j++) {
				       // we need to check again, since 
					   // manipulation of map[i] can occur within
					   // the j-loop
					   if(map[i] != -1) {
					       if(map[j] != -1) {
						      var djj = distanceMetric(k1[j],k2[map[j]]);
                              var dij = distanceMetric(k1[j],k2[map[i]]);
                              var dji = distanceMetric(k1[i],k2[map[j]]);
							  if(dji + dij < dii + djj) {
							      var mapj = map[j];
								  map[j] = map[i];
								  map[i] = mapj;
								  dii = dij;
							  }
						   } else {
						       var dij = distanceMetric(k1[j], k2[map[i]]);
                               if(dij < dii) {
                                  map[j] = map[i];
                                  map[i] = -1;
                                  dii = dij;
							    }
						   }
					   }
				   }				   
               }
		   }
	   }
       return map;	   
	}
	
	function completeMap(k1, k2, distanceMetric, map) {
	    if(!map.includes(-1)) {
		    return map;
		}
		// complete at the end

		var lastUnassigned = map[map.length];
		var mapLastTo = -1;
		for(var i = map.length -1; i>=0;i--) {
		    console.log("at map i:");
		    console.log(i);
		    if(map[i] == -1) {
			    lastUnassigned = i;
			} else {
			    mapLastTo = map[i];
			    break;
			}
		}
		console.log("map last to:");
		console.log(mapLastTo);
		for(var i=lastUnassigned;i<map.length;i++) {
		    map[i] = mapLastTo;
		}
		console.log("after end comp");
console.log(map);
		// complete at the beginning
		var firstUnassigned = -1;
		var mapFirstTo = -1;
		for(var i = 0;i<map.length;i++) {
		    if(map[i] == -1) {
			    firstUnassigned = i;
			} else {
			    mapFirstTo = map[i];
				break;
			}
		}		
		for(var i=0;i<=firstUnassigned;i++) {
		    map[i] = mapFirstTo;
		}
		// for the remaining unassigned, check
		// where to "split"

        for(var i=0;i<map.length;i++) {
            if(i+1 < map.length && map[i+1] == -1) {
               // we have a situation like this:
               //   i       i+1   i+2   ...  i+n 
               //   start   -1    ?     -1   stop
               var start = i;

               var stop = i+1;
               while(stop<map.length && map[stop] == -1) {
                  stop++;
               }

               var div = start;
               var max_dist = 1000000;
               for(var j=start;j<stop;j++) {
                   var stroke_ab = k1[start];
				   // iteration of concat, possibly slow
				   // due to memory allocations; optimize?!
			     	for(var temp=start+1;temp<=j;temp++) {
				       stroke_ab = stroke_ab.concat(k1[temp]);
			    	}
				   var stroke_bc = k1[j+1];

				   for(var temp=j+2;temp<=stop;temp++) {
				       stroke_bc = stroke_bc.concat(k1[temp]);
				   }
				   console.log("stroke bc:");
				   console.log(stroke_bc);
				   console.log("k2");
				   console.log(k2[map[stop]]);
				   var d_ab = distanceMetric(stroke_ab, k2[map[start]]);
				   var d_bc = distanceMetric(stroke_bc, k2[map[stop]]);				
                   if(d_ab + d_bc < max_dist) {
                       div = j;
                       max_dist = d_ab + d_bc;
                   }
               }
               for(var j=start;j<=div;j++) {
                   map[j] = map[start];
               }
               for(var j=div+1;j<stop;j++) {
                   map[j] = map[stop];
               }
            } 
        }
    return map;
	}
	
	function computeDistance(pattern1, pattern2, distanceMetric, map) {
	     var [k1,k2,n,m] = getLargerAndSize(pattern1, pattern2);
		 var dist = 0.0;
		 var idx = 0;
		 while(idx < n) {
		     var stroke_idx = k1[idx];
			 var start = map[idx];
			 var stop  = start+1;
			 while(stop<map.length && map[stop] == start) {
                  stop++;
             }
			 console.log("stop");
			 console.log(stop);
			 var stroke_concat = k2[start];
			 for(var temp=start+1;temp<stop;temp++) {
				stroke_concat = stroke_concat.concat(k2[map[temp]]);
			 }
			 console.log("dist: ");
			 console.log(stroke_idx);
			 console.log(k2);
			 console.log(stroke_concat);
			 dist += distanceMetric(stroke_idx, stroke_concat);
			 idx += 1;
		 }
		 return dist;
	}
	
	
	function coarseClassification(inputPattern)  {
	   var inputLength = inputPattern.length;
	   var candidates = [];
	   for(var i=0;i<refPatterns.length;i++) {
	       var iLength = refPatterns[i][1];
		   if(inputLength < iLength + 10 && inputLength > iLength-2) {
		       var iPattern = refPatterns[i][2];
			   var iMap = getMap(iPattern, inputPattern, endPointDistance);
			   iMap =  completeMap(iPattern, inputPattern, endPointDistance, iMap);
			   var dist = computeDistance(iPattern, inputPattern, endPointDistance, iMap);
			   candidates.push([i, dist]);
		   }
	   }
	   candidates.sort(function(a, b){return a[1]-b[1]});
	   var outStr = "";
	   for(var i=0;i<candidates.length;i++) {
	       outStr += candidates[i][0];
		   outStr += " ";
		   outStr += candidates[i][1];
		   outStr += refPatterns[candidates[i][0]][0];
		   outStr += "|";	   
	   }	   
	   document.getElementById("candidateList").innerHTML = outStr;	   
	} 
	
	function testMap() {
	  // var map = initStrokeMap(test_k21,test_k2,endPointDistance);
	    // should give
        // 0  1  2 3 
        // 0 -1 -1 1  
	  var map = getMap(test_k21,test_k2,endPointDistance);
	    // should also give
        // 0  1  2 3 
        // 0 -1 -1 1  
	  map = completeMap(test_k21,test_k2,endPointDistance, map);
	    // should give
        // 0  1  2 3 
        // 0 0 1 1  
	  console.log(map);	
	  
	  map = getMap(test_k22,test_k2,endPointDistance);
	    // 0  1  2 3 
        // 0 -1 -1 1
	  map = completeMap(test_k22,test_k2,endPointDistance, map);
       // 0 1 2 3 
        // 0 0 0 1  
	  console.log(map);	
	  
	  	  map = getMap(test_k23,test_k2,endPointDistance);
        // 0  1  2 3 
        // 0 -1 -1 1   
	  map = completeMap(test_k23,test_k2,endPointDistance, map);
        // 0  1  2 3 
        // 0  1  1 1
	  console.log(map);	
	}
	
	function testAll() {

	   normalizeLinear();

	   var extractedFeatures = extractFeatures(recordedPattern, 20.);

	   var map = getMap(extractedFeatures, refPatterns[0][2] ,endPointDistance);
	   console.log("map");
	   console.log(map);
	   map = completeMap(extractedFeatures, refPatterns[0][2],endPointDistance, map);

	   coarseClassification(extractedFeatures);
	}
	
   

//<button onclick="normalizeLinear()" style = "position:absolute;top:390;left:50;width:40;height:30;">test</button>

</script>
<body onload="init()">
  <canvas id="can" width="256" height="256" style="position:absolute;top:50;left:50;border:2px solid;"></canvas>

  <button onclick="erase()" style = "position:absolute;top:320;left:50;width:70;height:30;">Erase</button>
  <button onclick="deleteLast()" width= "200" style = "position:absolute;top:320;left:120;width:150;height:30;">Erase Last Stroke</button>
  <button onclick="recognize()" style = "position:absolute;top:320;left:270;width:40;height:30;">&#128269;</button>
  
  <button onclick="extractTest()" style = "position:absolute;top:390;left:50;width:40;height:30;">extract test</button>
  <button onclick="testMap()" style = "position:absolute;top:390;left:200;width:40;height:30;">map test</button>
  <button onclick="testAll()" style = "position:absolute;top:390;left:250;width:40;height:30;">test all</button>
  <div id="candidateList" style = "position:absolute;top:360;left:50;">Results </div>
</body>
</html>
