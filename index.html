<meta charset="UTF-8">
<html>
<script type="text/javascript">
  var canvas, ctx, flagOver, flagDown = false,
  prevX = 0,
  currX = 0,
  prevY = 0,
  currY = 0,
  dot_flag = false;

  var recordedPattern = new Array();
  var curentLine;

  // test data, remove for production
  var test_k2 = [ [ [0,10], [30,10], [60,10] ]   , [ [170,10], [200,10], [220,10] ] ];
  var test_k21 = [ [ [10,15], [30,15], [50,15]  ], [ [50,15], [55,15], [60,15] ], [ [170,15], [175,15], [180,15]  ], [ [180,15], [220,15]  ] ];
  var test_k22 = [ [ [0,15], [40,15] ], [ [40,15], [50,15] ], [ [50,15], [50,15]], [ [170,15], [220,15]  ] ];
 var test_k23 = [ [ [0,15], [60,15] ], [ [170,15], [180,15] ], [ [180,15], [190,15]], [ [170,15], [220,15]  ] ];
var test4 = [[[78, 87], [80, 87], [81, 87], [82, 87], [83, 87], [85, 87], [86, 87], [87, 87], [88, 87], [89, 87], [90, 87], [91, 87], [92, 87], [93, 87], [94, 87], [95, 87], [96, 87], [97, 87], [99, 87], [100, 87], [102, 87], [103, 87], [104, 87], [105, 87], [106, 87], [107, 87], [108, 87], [109, 87], [110, 87], [111, 87], [112, 87], [114, 87], [116, 87], [117, 87], [118, 87], [119, 87], [120, 87], [121, 87], [122, 87], [123, 87], [125, 87], [126, 87], [127, 87], [128, 87], [130, 87], [131, 87], [132, 87], [134, 87], [135, 87], [137, 87], [139, 87], [140, 87], [142, 87], [144, 87], [145, 87], [146, 87], [147, 87], [148, 87], [149, 87], [151, 87], [152, 87], [153, 86], [154, 86], [155, 86], [156, 85], [157, 85], [158, 85], [159, 85], [160, 85], [161, 85], [162, 85], [163, 85], [164, 84], [165, 84], [166, 84], [167, 84], [168, 84], [169, 84], [170, 84], [172, 84], [173, 84], [175, 83], [176, 83], [177, 83], [178, 83], [179, 83], [180, 83], [182, 83], [183, 82], [184, 82], [185, 82], [186, 82]], [[68, 135], [69, 135], [71, 134], [72, 134], [73, 134], [74, 134], [76, 134], [77, 134], [78, 134], [80, 134], [82, 134], [83, 134], [84, 134], [85, 134], [87, 133], [88, 133], [90, 133], [92, 133], [93, 133], [95, 133], [97, 133], [99, 133], [101, 133], [102, 133], [103, 133], [106, 133], [107, 133], [108, 133], [109, 133], [110, 133], [111, 133], [112, 133], [113, 133], [114, 133], [115, 133], [117, 133], [118, 133], [119, 133], [120, 133], [121, 133], [123, 133], [124, 133], [125, 133], [126, 133], [127, 133], [128, 133], [130, 133], [132, 133], [132, 132], [133, 132], [135, 132], [136, 132], [137, 132], [138, 132], [139, 132], [140, 132], [142, 132], [144, 132], [146, 132], [147, 132], [148, 132], [149, 132], [150, 132], [151, 132], [152, 132], [153, 132], [154, 132], [156, 132], [157, 132], [158, 132], [159, 132], [160, 132], [161, 132], [163, 131], [164, 131], [166, 131], [167, 131], [168, 131], [170, 131], [171, 131], [172, 131], [173, 131], [175, 131], [176, 131], [176, 130], [177, 130], [178, 130], [180, 130], [181, 130], [182, 130], [184, 130], [185, 130], [186, 130], [187, 130], [188, 130], [189, 130], [190, 130], [192, 130], [193, 130], [195, 130], [196, 130], [197, 130], [198, 130], [199, 130], [200, 130], [201, 130], [202, 130], [203, 130]], [[109, 55], [109, 56], [109, 57], [109, 59], [109, 61], [109, 62], [109, 63], [109, 64], [109, 65], [109, 66], [109, 67], [109, 68], [109, 70], [109, 71], [109, 73], [109, 74], [109, 75], [109, 76], [109, 77], [109, 79], [109, 80], [109, 81], [109, 82], [109, 83], [109, 84], [109, 85], [109, 87], [109, 89], [109, 90], [109, 92], [109, 93], [109, 94], [109, 97], [110, 97], [110, 98], [110, 99], [110, 100], [110, 101], [110, 103], [110, 104], [110, 105], [110, 106], [110, 108], [110, 109], [111, 111], [111, 113], [111, 114], [111, 115], [111, 116], [111, 117], [111, 119], [111, 120], [111, 121], [111, 122], [111, 123], [111, 125], [111, 127], [111, 128], [111, 130], [111, 131], [111, 132], [110, 133], [110, 134], [110, 135], [110, 136], [109, 137], [109, 138], [109, 139], [109, 140], [109, 141], [108, 142], [108, 143], [107, 144], [107, 146], [106, 148], [106, 149], [105, 150], [104, 151], [104, 153], [103, 154], [103, 155], [102, 157], [101, 159], [100, 160], [100, 161], [99, 163], [98, 164], [98, 165], [98, 167], [97, 167], [96, 169], [96, 170], [96, 171], [95, 172], [95, 173], [94, 174], [94, 175], [93, 176], [93, 178], [92, 178], [92, 179], [91, 181], [90, 182], [89, 183], [89, 184], [89, 185], [88, 186], [87, 187], [87, 189], [86, 189], [85, 190], [85, 191], [84, 192], [83, 192]], [[160, 45], [160, 46], [159, 47], [159, 48], [159, 49], [159, 50], [159, 51], [159, 53], [159, 54], [159, 55], [159, 58], [159, 59], [159, 60], [159, 62], [159, 64], [159, 65], [159, 66], [159, 68], [159, 69], [159, 70], [159, 72], [159, 73], [159, 74], [159, 75], [158, 77], [158, 78], [158, 80], [158, 82], [157, 82], [157, 83], [157, 84], [157, 85], [157, 86], [157, 87], [157, 88], [157, 89], [156, 90], [156, 91], [156, 92], [156, 93], [156, 95], [156, 96], [156, 97], [156, 99], [156, 101], [156, 102], [156, 103], [156, 105], [156, 106], [156, 107], [156, 110], [156, 111], [156, 112], [156, 114], [156, 116], [156, 117], [156, 118], [156, 120], [157, 122], [157, 123], [157, 124], [157, 125], [157, 127], [158, 128], [158, 129], [158, 131], [159, 132], [159, 134], [159, 135], [159, 136], [159, 137], [159, 139], [159, 140], [159, 141], [159, 143], [159, 144], [159, 145], [159, 147], [159, 149], [159, 150], [159, 152], [159, 153], [159, 154], [159, 155], [159, 156], [159, 157], [159, 159], [159, 160], [159, 162], [159, 163], [159, 164], [159, 166], [159, 167], [159, 168], [158, 169], [158, 171], [158, 172], [158, 174], [158, 175], [158, 176], [158, 177], [157, 179], [157, 180], [157, 181], [157, 182], [157, 183], [156, 184], [156, 186], [156, 187], [156, 188], [156, 189], [156, 191], [156, 192], [156, 193], [156, 194], [156, 195], [156, 196], [156, 197]], [[129, 100], [129, 101], [130, 101], [131, 102], [132, 104], [133, 104], [133, 105], [134, 105], [134, 106], [135, 107], [136, 108], [136, 109], [138, 111], [139, 113], [140, 113], [140, 114], [141, 114], [141, 115], [141, 116], [142, 116], [143, 117]]];
  var refPatterns = [ ["い", 2, [  [[0,15], [30,13], [60,14]], [[0,10], [30,10], [60,10]] ] ] ,
                      ["を", 3, [  [[0,17], [30,17], [60,17]], [[0,15], [30,13], [60,12]], [[0,15], [30,13], [60,12]] ]  ] 
					] 
  
		
  function init() {
    canvas = document.getElementById('can');
    ctx = canvas.getContext("2d");
    w = canvas.width;
    h = canvas.height;

    canvas.addEventListener("mousemove", function (e) {
      findxy('move', e)
    }, false);
    canvas.addEventListener("mousedown", function (e) {
      findxy('down', e)
    }, false);
    canvas.addEventListener("mouseup", function (e) {
      findxy('up', e)
    }, false);
    canvas.addEventListener("mouseout", function (e) {
      findxy('out', e)
    }, false);
	canvas.addEventListener("mouseover", function (e) {
      findxy('over', e)
    }, false);
  }

  function draw() {
    ctx.beginPath();
    ctx.moveTo(prevX, prevY);
    ctx.lineTo(currX, currY);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.closePath();
  }

  function deleteLast() {
    ctx.clearRect(0, 0, w, h);
    for(var i = 0;i<recordedPattern.length-1;i++) {
      var stroke_i = recordedPattern[i];
      for(var j = 0; j<stroke_i.length-1;j++) {
        prevX = stroke_i[j][0];
        prevY = stroke_i[j][1];

        currX = stroke_i[j+1][0];
        currY = stroke_i[j+1][1];
        draw();
      }
    }
    recordedPattern.pop();
  }

  function erase() {
    ctx.clearRect(0, 0, w, h);
    recordedPattern.length = 0;
  }

  // add flag for button down!!!
  function findxy(res, e) {
    if (res == 'down') {
      prevX = currX;
      prevY = currY;
      currX = e.clientX - canvas.offsetLeft;
      currY = e.clientY - canvas.offsetTop;
      //console.log("DOWN");
      currentLine = new Array();
      currentLine.push([currX, currY]);

      flagDown = true;
	  flagOver = true;
      dot_flag = true;
      if (dot_flag) {
        ctx.beginPath();
        ctx.fillRect(currX, currY, 2, 2);
        ctx.closePath();
        dot_flag = false;
      }
    }
    if (res == 'up') {
      flagDown = false;
	  //console.log("UP");
	  if(flagOver == true) {
          recordedPattern.push(currentLine);
	  }
    }

    if (res == "out") {
      flagOver = false;
	  if(flagDown == true) {
	      recordedPattern.push(currentLine);
	  }
	  flagDown = false;
	  //console.log("OUT");
	  //if(currentLine.length != 0) {
	  //recordedPattern.push(currentLine);
	  //}
    }
	
	if (res == "over") {
      //flagOver = true;
	  //console.log("OVER");
	  //if(currentLine.length != 0) {
	  //recordedPattern.push(currentLine);
	  //}
    }

    if (res == 'move') {
	//console.log("MOVE");
      if (flagOver && flagDown) {
        prevX = currX;
        prevY = currY;
        currX = e.clientX - canvas.offsetLeft;
        currY = e.clientY - canvas.offsetTop;
        currentLine.push([prevX, prevY]);
        currentLine.push([currX, currY]);
        draw();
      }
    }
  }

  function redraw() {
      ctx.clearRect(0, 0, w, h);
      for(var i = 0;i<recordedPattern.length;i++) {
        var stroke_i = recordedPattern[i]
        for(var j = 0; j<stroke_i.length-1;j++) {
          prevX = stroke_i[j][0];
          prevY = stroke_i[j][1];

          currX = stroke_i[j+1][0];
          currY = stroke_i[j+1][1];
          draw();
        }
      }
  }

  function recognize() {
    document.getElementById("candidateList").innerHTML = "日本";
  }
  
    // linearly stretch drawn symbol
  function normalizeLinearTest(recordedPattern) {

    var normalizedPattern = new Array();
    newHeight = 256;
    newWidth = 256;
    xMin = 256;
    xMax = 0;
    yMin = 256;
    yMax = 0;
    // first determine drawn character width / length
    for(var i = 0;i<recordedPattern.length;i++) {
      var stroke_i = recordedPattern[i];
      for(var j = 0; j<stroke_i.length;j++) {
        x = stroke_i[j][0];
        y = stroke_i[j][1];
        if(x < xMin) {
          xMin = x;
        }
        if(x > xMax) {
          xMax = x;
        }
        if(y < yMin) {
          yMin = y;
        }
        if(y > yMax) {
          yMax = y;
        }
      }
    }
    oldHeight = Math.abs(yMax - yMin);
    oldWidth  = Math.abs(xMax - xMin);
    if(oldHeight > oldWidth) {
      oldWidth = oldHeight;
    } else {
      oldHeight = oldWidth;
    }

	// superfluous
    normalizedPattern = new Array();
    // normalize
    for(var i = 0;i<recordedPattern.length;i++) {
      var stroke_i = recordedPattern[i];
      var normalized_stroke_i = new Array();
      for(var j = 0; j<stroke_i.length;j++) {
        x = stroke_i[j][0];
        y = stroke_i[j][1];
        xNorm = (x - xMin) * (newWidth / oldWidth) ;
        yNorm = (y - yMin) * (newHeight / oldHeight);
        normalized_stroke_i.push([xNorm, yNorm]);
      }
      normalizedPattern.push(normalized_stroke_i);
    }
    //recordedPattern = normalizedPattern;
    //redraw();
	return normalizedPattern;
  }

  // linearly stretch drawn symbol
  function normalizeLinear() {

    var normalizedPattern = new Array();
    newHeight = 256;
    newWidth = 256;
    xMin = 256;
    xMax = 0;
    yMin = 256;
    yMax = 0;
    // first determine drawn character width / length
    for(var i = 0;i<recordedPattern.length;i++) {
      var stroke_i = recordedPattern[i];
      for(var j = 0; j<stroke_i.length;j++) {
        x = stroke_i[j][0];
        y = stroke_i[j][1];
        if(x < xMin) {
          xMin = x;
        }
        if(x > xMax) {
          xMax = x;
        }
        if(y < yMin) {
          yMin = y;
        }
        if(y > yMax) {
          yMax = y;
        }
      }
    }
    oldHeight = Math.abs(yMax - yMin);
    oldWidth  = Math.abs(xMax - xMin);
    if(oldHeight > oldWidth) {
      oldWidth = oldHeight;
    } else {
      oldHeight = oldWidth;
    }

	// superfluous
    normalizedPattern = new Array();
    // normalize
    for(var i = 0;i<recordedPattern.length;i++) {
      var stroke_i = recordedPattern[i];
      var normalized_stroke_i = new Array();
      for(var j = 0; j<stroke_i.length;j++) {
        x = stroke_i[j][0];
        y = stroke_i[j][1];
        xNorm = (x - xMin) * (newWidth / oldWidth) ;
        yNorm = (y - yMin) * (newHeight / oldHeight);
        normalized_stroke_i.push([xNorm, yNorm]);
      }
      normalizedPattern.push(normalized_stroke_i);
    }
    recordedPattern = normalizedPattern;
    redraw();
  }
  
  function euclid(x1y1, x2y2) {
      var a = x1y1[0] - x2y2[0];
      var b = x1y1[1] - x2y2[1];
      var c = Math.sqrt( a*a + b*b );
	  return c;
  }

  // extract points in regular intervals
  function extractFeatures(kanji, interval) {
      var extractedPattern = new Array();
      var nrStrokes = kanji.length;
	  for(var i = 0;i<nrStrokes;i++) {
	      var stroke_i = kanji[i];
		  var extractedStroke_i = new Array();
		  var dist = 0.0;
	      var j = 0;
		  while(j < stroke_i.length) {
		      // always add first point
		      if(j==0) {
			  	  var x1y1 = stroke_i[0];
		          extractedStroke_i.push(x1y1);
			  }
		      if(j > 0) {
			      var x1y1 = stroke_i[j-1];
				  var x2y2 = stroke_i[j];
		          dist += euclid(x1y1, x2y2);
              }
			  if((dist >= interval) && (j>1)) {
			      dist = dist - interval;
				  var x1y1 = stroke_i[j];
				  extractedStroke_i.push(x1y1);
			  }
			  j++;
		  }
		  // if we so far have only one point, always add last point
		  if(extractedStroke_i.length == 1) {
		      var x1y1 = stroke_i[stroke_i.length-1];
		      extractedStroke_i.push(x1y1);
		  } else {
		      if(dist > (0.75 * interval)) {
			      var x1y1 = stroke_i[stroke_i.length-1];
		          extractedStroke_i.push(x1y1);
			  }		  
		  }
		  extractedPattern.push(extractedStroke_i);
	  }
      return extractedPattern;
   }
   
   function extractTest() {
      //var ex = extractFeatures(recordedPattern, 20.);
	  //recordedPattern = ex;

      //redraw();
	  
	  var norm = normalizeLinearTest(test4);
	  var ex = extractFeatures(norm, 20.);
	  console.log(ex);
	  
   }
   
   function endPointDistance(pattern1, pattern2) {
       var dist = 0;
	   var l1 = pattern1.length;
	   var l2 = pattern2.length;
       if(l1 == 0 || l2 == 0) {
          return 0;
       } else {
	       var x1y1 = pattern1[0];
		   var x2y2 = pattern2[0];
		   dist += (Math.abs(x1y1[0] - x2y2[0]) + Math.abs(x1y1[1] - x2y2[1]));
           x1y1 = pattern1[l1-1];
		   x2y2 = pattern2[l2-1];
		   dist += (Math.abs(x1y1[0] - x2y2[0]) + Math.abs(x1y1[1] - x2y2[1]));
	   }
	   return dist;
   }
   
   function initialDistance(pattern1, pattern2) {
       var l1 = pattern1.length;
	   var l2 = pattern2.length;
	   var lmin = Math.min(l1,l2);
	   var dist = 0;
	   for(var i = 0; i<lmin;i++) {
	       var x1y1 = pattern1[i];
		   var x2y2 = pattern2[i];
	       dist += (Math.abs(x1y1[0] - x2y2[0]) + Math.abs(x1y1[1] - x2y2[1]));
	   }
	   return dist;
   }
   
   function getLargerAndSize(pattern1, pattern2) {
	   var l1 = pattern1.length;
	   var l2 = pattern2.length;
	   // definitions as in paper 
	   // i.e. n is larger 
	   var n = l1;
	   var m = l2;
	   var k1 = pattern1;
	   var k2 = pattern2;
	   if(l1 < l2) {
	       m = l1;
		   n = l2;
		   k1 = pattern2;
		   k2 = pattern1;
	   }	   	   
       return [k1,k2,n,m];
   }
   
   function wholeWholeDistance(pattern1, pattern2) {
       var [k1,k2,n,m] = getLargerAndSize(pattern1, pattern2);
	   // larger is now k1 with length n
	   //console.log("whole whole dist");
	   //console.log(k1);
	   //console.log(k2);
	   var dist = 0;
	   //console.log("n");
	   //console.log(n);
	   for(var i = 0; i<m;i++) {
	       j_of_i = parseInt(parseInt(n/m) * i);
		   //console.log(j_of_i);
		   var x1y1 = k1[j_of_i];
		   var x2y2 = k2[i];
	       dist += (Math.abs(x1y1[0] - x2y2[0]) + Math.abs(x1y1[1] - x2y2[1]));
	   }
	   return parseInt(dist/m);
   }
   
   function initStrokeMap(pattern1, pattern2, distanceMetric) {
	   var [k1,k2,n,m] = getLargerAndSize(pattern1, pattern2);
	   // larger is now k1 with length n
	   var map = new Array();
	   for(var i=0;i<n;i++) {
	      map[i] = -1;
	   }
	   var free = new Array();
	   for(var i=0;i<n;i++) {
	      free[i] = true;
	   }
	   for(var i=0;i<m;i++) {
           minDist = 10000000;
		   min_j = -1;
		   for(var j=0;j<n;j++) {
		       if(free[j] == true) {
			       var d = distanceMetric(k1[j],k2[i]);
  			       if(d < minDist) {
				       minDist = d;
					   min_j = j;
			       }
			   }
		   }
		   free[min_j] = false;
           map[min_j] = i;
       }	   
	   return map;   
    }

	function getMap(pattern1, pattern2, distanceMetric) {
       var [k1,k2,n,m] = getLargerAndSize(pattern1, pattern2);
	   // larger is now k1 with length n
	   var L = 3;
	   var map = initStrokeMap(k1, k2, distanceMetric);
	   for(var l=0;l<L;l++) {
	       for(var i=0;i<map.length;i++) {
		       if(map[i] != -1) {
                   dii = distanceMetric(k1[i], k2[map[i]]);
				   for(var j=0;j<map.length;j++) {
				       // we need to check again, since 
					   // manipulation of map[i] can occur within
					   // the j-loop
					   if(map[i] != -1) {
					       if(map[j] != -1) {
						      var djj = distanceMetric(k1[j],k2[map[j]]);
                              var dij = distanceMetric(k1[j],k2[map[i]]);
                              var dji = distanceMetric(k1[i],k2[map[j]]);
							  if(dji + dij < dii + djj) {
							      var mapj = map[j];
								  map[j] = map[i];
								  map[i] = mapj;
								  dii = dij;
							  }
						   } else {
						       var dij = distanceMetric(k1[j], k2[map[i]]);
                               if(dij < dii) {
                                  map[j] = map[i];
                                  map[i] = -1;
                                  dii = dij;
							    }
						   }
					   }
				   }				   
               }
		   }
	   }
       return map;	   
	}
	
	function completeMap(k1, k2, distanceMetric, map) {
	    if(!map.includes(-1)) {
		    return map;
		}
		// complete at the end

		var lastUnassigned = map[map.length];
		var mapLastTo = -1;
		for(var i = map.length -1; i>=0;i--) {
		    //console.log("at map i:");
		    //console.log(i);
		    if(map[i] == -1) {
			    lastUnassigned = i;
			} else {
			    mapLastTo = map[i];
			    break;
			}
		}
		//console.log("map last to:");
		//console.log(mapLastTo);
		for(var i=lastUnassigned;i<map.length;i++) {
		    map[i] = mapLastTo;
		}
		//console.log("after end comp");
        //console.log(map);
		// complete at the beginning
		var firstUnassigned = -1;
		var mapFirstTo = -1;
		for(var i = 0;i<map.length;i++) {
		    if(map[i] == -1) {
			    firstUnassigned = i;
			} else {
			    mapFirstTo = map[i];
				break;
			}
		}		
		for(var i=0;i<=firstUnassigned;i++) {
		    map[i] = mapFirstTo;
		}
		// for the remaining unassigned, check
		// where to "split"

        for(var i=0;i<map.length;i++) {
            if(i+1 < map.length && map[i+1] == -1) {
               // we have a situation like this:
               //   i       i+1   i+2   ...  i+n 
               //   start   -1    ?     -1   stop
               var start = i;

               var stop = i+1;
               while(stop<map.length && map[stop] == -1) {
                  stop++;
               }

               var div = start;
               var max_dist = 1000000;
               for(var j=start;j<stop;j++) {
                   var stroke_ab = k1[start];
				   // iteration of concat, possibly slow
				   // due to memory allocations; optimize?!
			     	for(var temp=start+1;temp<=j;temp++) {
				       stroke_ab = stroke_ab.concat(k1[temp]);
			    	}
				   var stroke_bc = k1[j+1];

				   for(var temp=j+2;temp<=stop;temp++) {
				       stroke_bc = stroke_bc.concat(k1[temp]);
				   }
				   //console.log("stroke bc:");
				   //console.log(stroke_bc);
				   //console.log("k2");
				   //console.log(k2[map[stop]]);
				   var d_ab = distanceMetric(stroke_ab, k2[map[start]]);
				   var d_bc = distanceMetric(stroke_bc, k2[map[stop]]);				
                   if(d_ab + d_bc < max_dist) {
                       div = j;
                       max_dist = d_ab + d_bc;
                   }
               }
               for(var j=start;j<=div;j++) {
                   map[j] = map[start];
               }
               for(var j=div+1;j<stop;j++) {
                   map[j] = map[stop];
               }
            } 
        }
    return map;
	}
	
	function computeDistance(pattern1, pattern2, distanceMetric, map) {
	     var [k1,k2,n,m] = getLargerAndSize(pattern1, pattern2);
		 var dist = 0.0;
		 var idx = 0;
		 while(idx < n) {
		     var stroke_idx = k1[idx];
			 var start = map[idx];
			 var stop  = start+1;
			 while(stop<map.length && map[stop] == start) {
                  stop++;
             }
			 //console.log("stop");
			 //console.log(stop);
			 var stroke_concat = k2[start];
			 for(var temp=start+1;temp<stop;temp++) {
				stroke_concat = stroke_concat.concat(k2[map[temp]]);
			 }
			 //console.log("dist: ");
			 //console.log(stroke_idx);
			 //console.log(k2);
			 //console.log(stroke_concat);
			 dist += distanceMetric(stroke_idx, stroke_concat);
			 idx += 1;
		 }
		 return dist;
	}
	
	function computeWholeDistanceWeighted(pattern1, pattern2, map) {
	     var [k1,k2,n,m] = getLargerAndSize(pattern1, pattern2);
		 //console.log("whole weighted, k1: ");
		//	 console.log(k1);
		//	 console.log(n);
			 
		 var dist = 0.0;
		 var idx = 0;
		 while(idx < n) {
		     var stroke_idx = k1[idx];
			 var start = map[idx];
			 var stop  = start+1;
			 while(stop<map.length && map[stop] == start) {
                  stop++;
             }
			 //console.log("stop");
			 //console.log(stop);
			 var stroke_concat = k2[start];
			 for(var temp=start+1;temp<stop;temp++) {
				stroke_concat = stroke_concat.concat(k2[map[temp]]);
			 }
			 
			 //console.log("whole weighted, k1: ");
			 //console.log(k1);
			 //console.log(n);
			 /*
			 console.log(idx);
			 console.log(k1[idx]);
			 console.log("whole weighted, k2: ");
			 console.log(k2);			 
			 console.log("whole weighted, stroke_idx: ");
			 console.log(stroke_idx);
			 console.log("whole weighted, stroke_concat: ");
			 console.log(stroke_concat);
			 */
			 var dist_idx = wholeWholeDistance(stroke_idx, stroke_concat);
			 if(stop > start + 1) {
			    // concatenated stroke, adjust weight
				var mm = stroke_idx.length;
				var nn = stroke_concat.length;
				if(nn < mm) {
				   var temp = nn;
				   nn = mm;
				   mm = temp;
				}
                dist_idx = dist_idx * (nn/mm);				
			 }
			 dist += dist_idx;
			 idx += 1;
		 }
		 return dist;
	}
	
	
	function coarseClassification(inputPattern)  {
	   var inputLength = inputPattern.length;
	   var candidates = [];
	   for(var i=0;i<refPatterns.length;i++) {
	       var iLength = refPatterns[i][1];
		   if(inputLength < iLength + 10 && inputLength > iLength-2) {
		       var iPattern = refPatterns[i][2];
			   var iMap = getMap(iPattern, inputPattern, endPointDistance);
			   iMap =  completeMap(iPattern, inputPattern, endPointDistance, iMap);
			   var dist = computeDistance(iPattern, inputPattern, endPointDistance, iMap);
			   var m = iLength;
			   var n = iPattern.length;
			   if(n < m) {
			       var temp = n;
				   n = m;
				   m = temp;
			   }
			   candidates.push([i, (dist * (m/n))]);
		   }
	   }
	   candidates.sort(function(a, b){return a[1]-b[1]});
	   /*
	   var outStr = "";
	   for(var i=0;i<candidates.length;i++) {
	       outStr += candidates[i][0];
		   outStr += " ";
		   outStr += candidates[i][1];
		   outStr += refPatterns[candidates[i][0]][0];
		   outStr += "|";	   
	   }	   
	   document.getElementById("candidateList").innerHTML = outStr;
	   */
	   return candidates;
	}
	
	function fineClassification(inputPattern, inputCandidates) {
	   var inputLength = inputPattern.length;
	   var candidates = [];
	   for(var i=0;i<Math.min(inputCandidates.length, 100);i++) {
	       var j = inputCandidates[i][0];
	       var iLength = refPatterns[j][1];
		   var iPattern = refPatterns[j][2];
		   var iMap = getMap(iPattern, inputPattern, initialDistance);
		   //console.log("fine classif.")
		   //console.log(inputPattern);
		   //console.log(iPattern);
		   iMap =  completeMap(iPattern, inputPattern, wholeWholeDistance, iMap);
		   //console.log("finished imap, fine:");
		   //console.log(iMap);
		   var dist = computeWholeDistanceWeighted(iPattern, inputPattern, iMap);
		   //var dist = computeDistance(iPattern, inputPattern, wholeWholeDistance, iMap);
		   var n = inputLength;
		   var m = iPattern.length;
		   if(m > n) {
		       m = n;
		   }
		   dist = dist / m;
		   candidates.push([j, dist]);
	   }
	   candidates.sort(function(a, b){return a[1]-b[1]});
	   var outStr = "";
	   for(var i=0;i<candidates.length;i++) {
	       outStr += candidates[i][0];
		   outStr += " ";
		   outStr += candidates[i][1];
		   outStr += refPatterns[candidates[i][0]][0];
		   outStr += "|";	   
	   }	   
	   document.getElementById("candidateList").innerHTML = outStr;
	}
	
	function testMap() {
	  // var map = initStrokeMap(test_k21,test_k2,endPointDistance);
	    // should give
        // 0  1  2 3 
        // 0 -1 -1 1  
	  var map = getMap(test_k21,test_k2,endPointDistance);
	    // should also give
        // 0  1  2 3 
        // 0 -1 -1 1  
	  map = completeMap(test_k21,test_k2,endPointDistance, map);
	    // should give
        // 0  1  2 3 
        // 0 0 1 1  
	  console.log(map);	
	  
	  map = getMap(test_k22,test_k2,endPointDistance);
	    // 0  1  2 3 
        // 0 -1 -1 1
	  map = completeMap(test_k22,test_k2,endPointDistance, map);
       // 0 1 2 3 
        // 0 0 0 1  
	  console.log(map);	
	  
	  	  map = getMap(test_k23,test_k2,endPointDistance);
        // 0  1  2 3 
        // 0 -1 -1 1   
	  map = completeMap(test_k23,test_k2,endPointDistance, map);
        // 0  1  2 3 
        // 0  1  1 1
	  console.log(map);	
	}
	
	function testAll() {

	   normalizeLinear();

	   var extractedFeatures = extractFeatures(recordedPattern, 20.);

	   var map = getMap(extractedFeatures, refPatterns[0][2] ,endPointDistance);
	   console.log("map");
	   console.log(map);
	   map = completeMap(extractedFeatures, refPatterns[0][2],endPointDistance, map);

	   var candidates = coarseClassification(extractedFeatures);
	   fineClassification(extractedFeatures, candidates);
	}
	
   

//<button onclick="normalizeLinear()" style = "position:absolute;top:390;left:50;width:40;height:30;">test</button>

</script>
<body onload="init()">
  <canvas id="can" width="256" height="256" style="position:absolute;top:50;left:50;border:2px solid;"></canvas>

  <button onclick="erase()" style = "position:absolute;top:320;left:50;width:70;height:30;">Erase</button>
  <button onclick="deleteLast()" width= "200" style = "position:absolute;top:320;left:120;width:150;height:30;">Erase Last Stroke</button>
  <button onclick="recognize()" style = "position:absolute;top:320;left:270;width:40;height:30;">&#128269;</button>
  
  <button onclick="extractTest()" style = "position:absolute;top:390;left:50;width:40;height:30;">extract test</button>
  <button onclick="testMap()" style = "position:absolute;top:390;left:200;width:40;height:30;">map test</button>
  <button onclick="testAll()" style = "position:absolute;top:390;left:250;width:40;height:30;">test all</button>
  <div id="candidateList" style = "position:absolute;top:360;left:50;">Results </div>
</body>
</html>
